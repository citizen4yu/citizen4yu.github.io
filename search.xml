<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[libvirt rpc原理]]></title>
    <url>%2F2018%2F06%2F24%2Flibvirt-rpc%2F</url>
    <content type="text"><![CDATA[libvirt rpc原理libvirt一种很流行的虚拟化管理toolkit，基于C语言实现，并且提供python、java、go等多种语言的bindings，常用的命令集工具virsh。bindings和virsh是通过rpc的方式调用不同的虚拟化平台driver的API，达到最终实现功能的效果。其中，libvirt主daemon程序libvirtd作为rpc server端，bindings、virsh作为rpc client。libvirt rpc使用的是标准的XDR协议。libvirt rpc协议。 rpc调用流程： rpc server流程libvirtd main()中，初始化libvirtd server， 再初始化rpc server，并add rpc server到libvirtd server programs链上。当有rpc client端调用时，发送API参数到rpc server，rpc server解析API参数，调用对应的hypervsior driver API，正确处理后返回结果到rpc client。 rpc server端能被多个rpc client连接。 123456789main virNetServerNew virNetServerHandleJob 创建线程池，注册回调 virNetServerProcessMsg 处理rpc server program消息 virNetServerProgramDispatch 分发到remote server program virNetServerProgramDispatchCall 调到remote driver，由remote在调用某一具体hypervisor driver virNetServerProgramNew virNetServerAddProgram virNetDaemonRun mainloop等待rpc client调用 rpc client端流程不管是bindings，还是virsh调用libvirtd hypervisor driver API，首先需要建立connect，这里connect有多种方式（ssh、unix、tls、tcp等），再创建remote client program，组织API参数，发送给rpc server。 rpc client创建的connect可被多个操作使用。 1234567virConnectOpen 或者virConnectOpenAuth、virConnectOpenReadOnly根据需要 virConnectOpenInternal virGetConnect 创建connect object remoteConnectOpen doRemoteOpen virNetClientNewUNIX unix连接方式的client（根据连接方式不同） virNetClientProgramNew 创建remote client program 以list all domain为例，看rpc client调用流程：1234567891011virConnectListAllDomains hypevisor driver API connectListAllDomains remoteConnectListAllDomains src/remote/remote_client_bodies.h,编译时gendispatch.pl根据src/remote/remote_protocol.x自动生成 call callFull virNetClientProgramCall virNetClientSendWithReply virNetClientSendInternal virNetClientIO virNetClientIOEventLoop poll]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>libvirt rpc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qemu memory]]></title>
    <url>%2F2018%2F05%2F17%2Fqemu-memory%2F</url>
    <content type="text"><![CDATA[qemu memory分为2部分，qemu层初始化，kvm层实际分配。 1 qemu层初始化1.1 注册memory管理callback先上代码栈： main configure_accelerator accel_init_machine kvm_init kvm_memory_listener_register memory_listener_register 重点看以下2个函数和1个结构体：kvm_memory_listener_register()分配system memory listener,最终也是调用的memory_listener_register()memory_listener_register()分配IO memory listenerMemoryListener可以理解为qemu memory管理的函数簇 void kvm_memory_listener_register(KVMState *s, KVMMemoryListener *kml, AddressSpace *as, int as_id) { int i; kml-&gt;slots = g_malloc0(s-&gt;nr_slots * sizeof(KVMSlot)); kml-&gt;as_id = as_id; 分配slot，可配置(libvirt xml memory slot, 或是使用默认32) for (i = 0; i &lt; s-&gt;nr_slots; i++) { kml-&gt;slots[i].slot = i; } 初始化callback kml-&gt;listener.region_add = kvm_region_add; kml-&gt;listener.region_del = kvm_region_del; kml-&gt;listener.log_start = kvm_log_start; kml-&gt;listener.log_stop = kvm_log_stop; kml-&gt;listener.log_sync = kvm_log_sync; kml-&gt;listener.priority = 10; memory_listener_register(&amp;kml-&gt;listener, as); } void memory_listener_register(MemoryListener *listener, AddressSpace *filter) { MemoryListener *other = NULL; AddressSpace *as; listener-&gt;address_space_filter = filter; 如果listener链表为空或是当前listener优先级比链表中最后一个的优先级还大则直接插入链表最后 if (QTAILQ_EMPTY(&amp;memory_listeners) || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners, memory_listeners)-&gt;priority) { QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link); } else { listener链表不为空，则找到第1个优先级比其打的插入之前 QTAILQ_FOREACH(other, &amp;memory_listeners, link) { if (listener-&gt;priority &lt; other-&gt;priority) { break; } } QTAILQ_INSERT_BEFORE(other, listener, link); } QTAILQ_FOREACH(as, &amp;address_spaces, address_spaces_link) { listener_add_address_space(listener, as); } } 1.2 初始化内存管理数据结构从cpu_exec_init_all()开始，该初始化在MemoryListener之前，初始化IO memory函数簇，IO、system memory的MemoryRegion cpu_exec_init_all io_mem_init memory_region_init_io memory_map_init memory_region_init memory_region_init_io address_space_init memory_region_transaction_commit io_mem_init()初始化IO memory相关的MemoryRegion，最终会调用memory_region_init()，包括初始化必要的函数簇。memory_map_init初始化IO、system memory的MemoryRegion，没有函数簇需要初始化。另外，还是初始化IO、memory重要的全局变量AddressSpace。其中，address_space_init()最重要，初始化了整个qemu进程的memory链。 void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name) { memory_region_ref(root); memory_region_transaction_begin(); as-&gt;ref_count = 1; as-&gt;root = root; 使用上一步初始化的MemoryRegion as-&gt;malloced = false; as-&gt;current_map = g_new(FlatView, 1); flatview_init(as-&gt;current_map); 初始化FlatView as-&gt;ioeventfd_nb = 0; as-&gt;ioeventfds = NULL; QTAILQ_INSERT_TAIL(&amp;address_spaces, as, address_spaces_link); 插入初始化完成的AddressSpace as-&gt;name = g_strdup(name ? name : "anonymous"); address_space_init_dispatch(as); 初始化AddressSpace的dispatch_listener函数簇，个人认为改行放在AddressSpace插入链表前更合理 memory_region_update_pending |= root-&gt;enabled; memory_region_transaction_commit(); } 1.3 初始化machine流程中的memorymain machine_class-&gt;init(current_machine) pc_init_isa pc_init1 pc_memory_init 重点是pc_memory_init()，初始化pc.ram（ram-below-4g、ram-above-4g），hotplug-memory（如果支持）、pc firmware、pc.rom、firmware config。]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github + hexo = blog]]></title>
    <url>%2F2018%2F05%2F13%2Fgithub-hexo-blog%2F</url>
    <content type="text"><![CDATA[github 创建pages1234命名格式：yourname.github.io注意： yourname必须是你的github name，否则blog URL不是以上格式 安装hexo1234567安装hexo-cli npm install -g hexo-clihexo建站 $ hexo init &lt;your_blog_name&gt; $ cd &lt;your_blog_name&gt; $ npm install hexo部署到git上12345678910安装hexo-deployer-git npm install hexo-deployer-git --save修改_config.yml repo: 用git@作前缀，否则每次提交都需要输入github账号密码提交到github $ hexo clean $ hexo g $ hexo d hexo的Next主题12345678910111213下载next主题 在your_blog_name/thems目录下： git clone https://github.com/iissnan/hexo-theme-next themes/next配置为next主题 站点_config.yml下，找到thems字段，修改为next设置favicon图标 准备favicon.ico格式文件，放入source/images目录 修改配置文件_config.yml favicon: small: /images/favicon.ico medium: /images/favicon.ico:w 参考链接主要参考]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>github hexo blog</tag>
      </tags>
  </entry>
</search>
