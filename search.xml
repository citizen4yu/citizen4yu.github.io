<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[qemu_memory]]></title>
    <url>%2F2018%2F05%2F17%2Fqemu-memory%2F</url>
    <content type="text"><![CDATA[qemu memory分为2部分，qemu层初始化，kvm层实际分配。 1 qemu层初始化1.1 注册memory管理callback先上代码栈： main configure_accelerator accel_init_machine kvm_init kvm_memory_listener_register memory_listener_register 重点看以下2个函数和1个结构体：kvm_memory_listener_register()分配system memory listener,最终也是调用的memory_listener_register()memory_listener_register()分配IO memory listenerMemoryListener可以理解为qemu memory管理的函数簇 123456789101112131415161718192021222324void kvm_memory_listener_register(KVMState *s, KVMMemoryListener *kml, AddressSpace *as, int as_id) &#123; int i; kml-&gt;slots = g_malloc0(s-&gt;nr_slots * sizeof(KVMSlot)); kml-&gt;as_id = as_id; 分配slot，可配置(libvirt xml memory slot, 或是使用默认32) for (i = 0; i &lt; s-&gt;nr_slots; i++) &#123; kml-&gt;slots[i].slot = i; &#125; 初始化callback kml-&gt;listener.region_add = kvm_region_add; kml-&gt;listener.region_del = kvm_region_del; kml-&gt;listener.log_start = kvm_log_start; kml-&gt;listener.log_stop = kvm_log_stop; kml-&gt;listener.log_sync = kvm_log_sync; kml-&gt;listener.priority = 10; memory_listener_register(&amp;kml-&gt;listener, as); &#125;``` void memory_listener_register(MemoryListener listener, AddressSpace filter){ MemoryListener other = NULL; AddressSpace as; listener-&gt;address_space_filter = filter; 如果listener链表为空或是当前listener优先级比链表中最后一个的优先级还大则直接插入链表最后 if (QTAILQ_EMPTY(&amp;memory_listeners) || listener-&gt;priority &gt;= QTAILQ_LAST(&amp;memory_listeners, memory_listeners)-&gt;priority) { QTAILQ_INSERT_TAIL(&amp;memory_listeners, listener, link); } else { listener链表不为空，则找到第1个优先级比其打的插入之前 QTAILQ_FOREACH(other, &amp;memory_listeners, link) { if (listener-&gt;priority &lt; other-&gt;priority) { break; } } QTAILQ_INSERT_BEFORE(other, listener, link); } QTAILQ_FOREACH(as, &amp;address_spaces, address_spaces_link) { listener_add_address_space(listener, as); } }123456789101112131415### 1.2 初始化内存管理数据结构从`cpu_exec_init_all()`开始，该初始化在`MemoryListener`之前，初始化IO memory函数簇，IO、system memory的`MemoryRegion` cpu_exec_init_all io_mem_init memory_region_init_io memory_map_init memory_region_init memory_region_init_io address_space_init memory_region_transaction_commit `io_mem_init()`初始化IO memory相关的`MemoryRegion`，最终会调用`memory_region_init()`，包括初始化必要的函数簇。`memory_map_init`初始化IO、system memory的`MemoryRegion`，没有函数簇需要初始化。另外，还是初始化IO、memory重要的全局变量`AddressSpace`。其中，`address_space_init()`最重要，初始化了整个qemu进程的memory链。 void address_space_init(AddressSpace as, MemoryRegion root, const char *name){ memory_region_ref(root); memory_region_transaction_begin(); as-&gt;ref_count = 1; as-&gt;root = root; 使用上一步初始化的MemoryRegion as-&gt;malloced = false; as-&gt;current_map = g_new(FlatView, 1); flatview_init(as-&gt;current_map); 初始化FlatView as-&gt;ioeventfd_nb = 0; as-&gt;ioeventfds = NULL; QTAILQ_INSERT_TAIL(&amp;address_spaces, as, address_spaces_link); 插入初始化完成的AddressSpace as-&gt;name = g_strdup(name ? name : “anonymous”); address_space_init_dispatch(as); 初始化AddressSpace的dispatch_listener函数簇，个人认为改行放在AddressSpace插入链表前更合理 memory_region_update_pending |= root-&gt;enabled; memory_region_transaction_commit();}` 1.3 初始化machine流程中的memorymain machine_class-&gt;init(current_machine) pc_init_isa pc_init1]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>qemu memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github + hexo = blog]]></title>
    <url>%2F2018%2F05%2F13%2Fgithub-hexo-blog%2F</url>
    <content type="text"><![CDATA[github 创建pages1234命名格式：yourname.github.io注意： yourname必须是你的github name，否则blog URL不是以上格式 安装hexo1234567安装hexo-cli npm install -g hexo-clihexo建站 $ hexo init &lt;your_blog_name&gt; $ cd &lt;your_blog_name&gt; $ npm install hexo部署到git上12345678910安装hexo-deployer-git npm install hexo-deployer-git --save修改_config.yml repo: 用git@作前缀，否则每次提交都需要输入github账号密码提交到github $ hexo clean $ hexo g $ hexo d hexo的Next主题12345678910111213下载next主题 在your_blog_name/thems目录下： git clone https://github.com/iissnan/hexo-theme-next themes/next配置为next主题 站点_config.yml下，找到thems字段，修改为next设置favicon图标 准备favicon.ico格式文件，放入source/images目录 修改配置文件_config.yml favicon: small: /images/favicon.ico medium: /images/favicon.ico:w 参考链接主要参考]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>github hexo blog</tag>
      </tags>
  </entry>
</search>
